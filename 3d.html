<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CalcPro - Pro Max Engine</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; }
        canvas { display: block; }
        
        /* HUD Style Pro Max */
        #hud-pro {
            position: absolute; top: 20px; left: 20px;
            color: #00ffcc; border-left: 2px solid #00ffcc;
            padding: 10px 20px; background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px); pointer-events: none;
        }
        .scanner-line {
            width: 100%; height: 1px; background: #00ffcc;
            position: absolute; top: 0; opacity: 0.3;
            animation: scan 3s linear infinite;
        }
        @keyframes scan { from { top: 0%; } to { top: 100%; } }

        .btn-exit {
            position: absolute; bottom: 30px; right: 30px;
            padding: 12px 25px; border: 1px solid #ff007f;
            color: #ff007f; text-decoration: none;
            text-transform: uppercase; font-size: 10px; letter-spacing: 2px;
            border-radius: 50px; transition: 0.3s;
        }
        .btn-exit:hover { background: #ff007f; color: #000; box-shadow: 0 0 20px #ff007f; }
    </style>
</head>
<body>
    <div class="scanner-line"></div>
    <div id="hud-pro">
        <div style="letter-spacing: 3px; font-weight: bold;">PRO_MAX_ENGINE v9.0</div>
        <div id="log" style="font-size: 9px; color: #008877; margin-top: 5px;">SYSTEM_STABLE</div>
    </div>

    <a href="index.html" class="btn-exit">Terminer Session</a>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let w, h, points = [], angle = 0;

        function init() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            points = [];
            // Génération de la structure de l'algorithme (Nœuds développés)
            for(let i=0; i<30; i++) {
                points.push({
                    x: (Math.random() - 0.5) * 300,
                    y: (Math.random() - 0.5) * 300,
                    z: (Math.random() - 0.5) * 300,
                    targetX: (Math.random() - 0.5) * 300,
                    targetY: (Math.random() - 0.5) * 300,
                    targetZ: (Math.random() - 0.5) * 300
                });
            }
        }

        function project(x, y, z) {
            const perspective = 500 / (z + 600);
            return {
                x: x * perspective + w / 2,
                y: y * perspective + h / 2,
                s: perspective
            };
        }

        function draw() {
            // Effet de rémanence Pro
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, w, h);
            
            angle += 0.01;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);

            // Dessin des connexions (Factorisation des données)
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 255, 204, 0.2)';
            ctx.lineWidth = 0.5;

            points.forEach((p, i) => {
                // Rotation 3D
                let x = p.x * cos - p.z * sin;
                let z = p.x * sin + p.z * cos;
                let y = p.y * Math.cos(angle*0.5) - z * Math.sin(angle*0.5);
                
                let proj = project(x, y, z);

                // Animation de "Développement" (les points bougent)
                p.x += (p.targetX - p.x) * 0.01;
                p.y += (p.targetY - p.y) * 0.01;
                if(Math.abs(p.x - p.targetX) < 1) {
                    p.targetX = (Math.random() - 0.5) * 350;
                    p.targetY = (Math.random() - 0.5) * 350;
                }

                // Dessin des liens neuronaux
                points.slice(i+1, i+4).forEach(p2 => {
                    let proj2 = project(p2.x * cos - p2.z * sin, p2.y, p2.x * sin + p2.z * cos);
                    ctx.moveTo(proj.x, proj.y);
                    ctx.lineTo(proj2.x, proj2.y);
                });

                // Points lumineux
                ctx.fillStyle = i % 5 === 0 ? '#ff007f' : '#00ffcc';
                ctx.fillRect(proj.x-1, proj.y-1, 2, 2);
            });
            ctx.stroke();

            // HUD Log Update
            if(Math.random() > 0.95) {
                document.getElementById('log').innerText = "FACTOR_ID: " + Math.random().toString(16).slice(2,8).toUpperCase();
            }

            requestAnimationFrame(draw);
        }

        window.addEventListener('resize', init);
        init();
        draw();
    </script>
</body>
</html>
