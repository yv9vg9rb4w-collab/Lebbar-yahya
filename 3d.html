<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>A* Pathfinding Pro 3D</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #overlay { position: absolute; bottom: 20px; left: 20px; color: #0f0; background: rgba(0,20,0,0.8); padding: 15px; border: 1px solid #0f0; text-transform: uppercase; letter-spacing: 2px; pointer-events: none; }
        .stat { color: #fff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="overlay">
        System: <span class="stat">A-STAR_v2.0</span><br>
        Status: <span class="stat" id="status">Calcul en cours...</span><br>
        Grid: <span class="stat">20x20x20 (8,000 Nodes)</span>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SETUP PRO ---
        const size = 20;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        camera.position.set(30, 30, 30);

        // --- DONNÉES & ALGORITHME ---
        const grid = [];
        const start = {x:0, y:0, z:0};
        const end = {x:size-1, y:size-1, z:size-1};

        function createGrid() {
            for(let x=0; x<size; x++) {
                grid[x] = [];
                for(let y=0; y<size; y++) {
                    grid[x][y] = [];
                    for(let z=0; z<size; z++) {
                        grid[x][y][z] = {
                            x, y, z,
                            isWall: Math.random() < 0.3 && !(x===0 && y===0 && z===0) && !(x===size-1 && y===size-1 && z===size-1),
                            g: Infinity, h: 0, f: Infinity, parent: null
                        };
                    }
                }
            }
        }

        function aStar() {
            let openSet = [grid[start.x][start.y][start.z]];
            openSet[0].g = 0;
            
            while(openSet.length > 0) {
                let current = openSet.reduce((prev, curr) => prev.f < curr.f ? prev : curr);
                
                if(current.x === end.x && current.y === end.y && current.z === end.z) return current;

                openSet = openSet.filter(n => n !== current);
                
                const neighbors = [];
                [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]].forEach(d => {
                    let nx = current.x+d[0], ny = current.y+d[1], nz = current.z+d[2];
                    if(nx>=0 && nx<size && ny>=0 && ny<size && nz>=0 && nz<size) neighbors.push(grid[nx][ny][nz]);
                });

                for(let neighbor of neighbors) {
                    if(neighbor.isWall) continue;
                    let tentativeG = current.g + 1;
                    if(tentativeG < neighbor.g) {
                        neighbor.parent = current;
                        neighbor.g = tentativeG;
                        neighbor.h = Math.abs(neighbor.x-end.x) + Math.abs(neighbor.y-end.y) + Math.abs(neighbor.z-end.z);
                        neighbor.f = neighbor.g + neighbor.h;
                        if(!openSet.includes(neighbor)) openSet.push(neighbor);
                    }
                }
            }
            return null;
        }

        // --- RENDU INSTANCIÉ (OPTIMISÉ) ---
        createGrid();
        const pathEnd = aStar();
        document.getElementById('status').innerText = pathEnd ? "Chemin trouvé" : "Échec - Relancez";

        // Murs (Gris sombre)
        const wallGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const wallMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const wallMesh = new THREE.InstancedMesh(wallGeo, wallMat, size**3);
        
        // Chemin (Néon bleu)
        const pathMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const pathMesh = new THREE.InstancedMesh(wallGeo, pathMat, size*3);

        let wallIdx = 0;
        const dummy = new THREE.Object3D();

        for(let x=0; x<size; x++) {
            for(let y=0; y<size; y++) {
                for(let z=0; z<size; z++) {
                    if(grid[x][y][z].isWall) {
                        dummy.position.set(x, y, z);
                        dummy.updateMatrix();
                        wallMesh.setMatrixAt(wallIdx++, dummy.matrix);
                    }
                }
            }
        }
        scene.add(wallMesh);

        if(pathEnd) {
            let curr = pathEnd;
            let pIdx = 0;
            while(curr) {
                dummy.position.set(curr.x, curr.y, curr.z);
                dummy.updateMatrix();
                pathMesh.setMatrixAt(pIdx++, dummy.matrix);
                curr = curr.parent;
            }
            pathMesh.count = pIdx;
            scene.add(pathMesh);
        }

        // --- EFFETS ---
        const pLight = new THREE.PointLight(0x00ffff, 500, 100);
        pLight.position.set(size/2, size/2, size/2);
        scene.add(pLight);
        scene.add(new THREE.AmbientLight(0x404040));

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            pathMesh.position.y = Math.sin(time) * 0.2; // Petit flottement du chemin
            scene.rotation.y += 0.002;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
